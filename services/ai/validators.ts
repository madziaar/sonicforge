import { GeneratedPrompt } from "../../types";
import { GeneratedPromptSchema } from "../../types";
import { LIMITS } from "../../lib/constants";
import { sunoMetaTags } from "../../features/generator/data/sunoMetaTags";

// Common AI hallucinations mapped to valid Suno/Audio tags
const TAG_CORRECTIONS: Record<string, string> = {
  'fast pace': 'fast tempo',
  'slow pace': 'slow tempo',
  'female voice': 'female vocals',
  'male voice': 'male vocals',
  'instrumental only': 'instrumental',
  'synth pop': 'synthpop',
  'hip-hop': 'hip hop',
  'lo fi': 'lo-fi',
  'high quality': 'pristine production',
  'emotional': 'emotional vocals',
  'heavy bass': 'sub bass',
  'synthesizer': 'synth',
  'drum machine': 'drum machine',
  'acoustic guitar': 'acoustic guitar',
  'electric guitar': 'electric guitar',
  'upbeat': 'energetic',
  'sad': 'melancholic'
};

/**
 * Validates and partially fixes the AI response at runtime.
 * @param json The raw JSON object from the AI.
 * @returns A strictly typed GeneratedPrompt or throws/returns default.
 */
export const validateAIResponse = (json: any): GeneratedPrompt => {
  try {
    const parsed = GeneratedPromptSchema.parse(json);
    
    // Post-Validation Cleanup
    return {
      title: (parsed.title || "Untitled").substring(0, LIMITS.TITLE),
      tags: validateAndFixTags(parsed.tags),
      style: (parsed.style || '').substring(0, LIMITS.STYLE),
      lyrics: sanitizeLyrics(parsed.lyrics).substring(0, LIMITS.LYRICS),
      analysis: parsed.analysis,
    };
  } catch (error) {
    console.warn("AI Response Validation Failed:", error);
    // Fallback: Try to salvage what we can using safe casting
    return {
      title: String(json?.title ?? "Validation Error").substring(0, LIMITS.TITLE),
      tags: validateAndFixTags(String(json?.tags ?? "")),
      style: String(json?.style ?? "").substring(0, LIMITS.STYLE),
      lyrics: sanitizeLyrics(String(json?.lyrics ?? "")).substring(0, LIMITS.LYRICS),
      analysis: String(json?.analysis ?? "Error parsing model output."),
    };
  }
};

/**
 * Sanitizes and validates tags generated by the AI.
 * Enforces Suno V4.5 constraints: Lowercase, comma-separated, max 400 chars.
 * Applies auto-correction map.
 */
export const validateAndFixTags = (rawTags: string): string => {
  if (!rawTags) return "";

  // 1. Split and Clean
  const uniqueTags = new Set<string>();
  const parts = rawTags.split(',').map(t => t.trim().toLowerCase()).filter(t => t.length > 0);

  parts.forEach(tag => {
    // Remove trailing periods often added by LLMs
    let cleanTag = tag.replace(/\.$/, '');
    
    // Auto-Correct
    if (TAG_CORRECTIONS[cleanTag]) {
      cleanTag = TAG_CORRECTIONS[cleanTag];
    }

    uniqueTags.add(cleanTag);
  });

  // 2. Reassemble
  const result = Array.from(uniqueTags).join(', ');

  // 3. Hard Limit Check
  if (result.length > LIMITS.TAGS) {
    return result.substring(0, LIMITS.TAGS).replace(/,[^,]*$/, ''); // Cut off at last comma
  }

  return result;
};

/**
 * Ensures lyrics structure uses proper bracketing.
 */
export const sanitizeLyrics = (text: string): string => {
  if (!text) return "";
  // Fix common AI mistake: (Chorus) -> [Chorus]
  return text.replace(/\((intro|verse|chorus|bridge|outro|instrumental|solo|drop|build|pre-chorus)\)/gi, '[$1]');
};
